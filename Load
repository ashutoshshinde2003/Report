DECLARE
    l_blob      BLOB;
    l_file_name VARCHAR2(255);
    l_err_msg   VARCHAR2(4000);
    l_job_id    NUMBER;
    l_seq_no    NUMBER := 0;
    l_success   BOOLEAN := TRUE;
    l_status    VARCHAR2(20);
    l_row_count NUMBER := 0;
BEGIN
    -- 1. Get latest uploaded file from APEX temp files
    SELECT blob_content, filename
      INTO l_blob, l_file_name
      FROM (
        SELECT blob_content, filename
          FROM apex_application_temp_files
         WHERE application_id = :APP_ID
         ORDER BY created_on DESC
      )
     WHERE ROWNUM = 1;

    -- 2. Generate JOB_ID from your sequence
    SELECT bulk_resolution_seq.NEXTVAL INTO l_job_id FROM dual;

    -- 3. Insert header record
    INSERT INTO eres_bulk_res_upload_smry (
        job_id, created_by, created_dt, job_status
    ) VALUES (
        l_job_id, :APP_USER, SYSDATE, 'PENDING'
    );

    -- 4. Loop through Excel rows
    FOR rec IN (
        SELECT col001 AS pts_res_group_id
          FROM TABLE(
            apex_data_parser.parse(
                p_content   => l_blob,
                p_file_name => l_file_name,
                p_skip_rows => 1
            )
          )
    )
    LOOP
        l_seq_no := l_seq_no + 1;
        l_row_count := l_row_count +1;

        BEGIN
            -- Always insert row, classify VALID vs INVALID
            IF REGEXP_LIKE(rec.pts_res_group_id, '^\d+$') THEN
                INSERT INTO eres_bulk_res_upload_detail (
                    job_id, seq_no, pts_res_group_id, row_status, status
                ) VALUES (
                    l_job_id, l_seq_no, rec.pts_res_group_id, 'VALID', NULL
                );
            ELSE
                INSERT INTO eres_bulk_res_upload_detail (
                    job_id, seq_no, pts_res_group_id, row_status, status
                ) VALUES (
                    l_job_id, l_seq_no, rec.pts_res_group_id, 'INVALID', NULL
                );
                l_success := FALSE; -- mark job as failed if any invalid
            END IF;

        EXCEPTION
            WHEN OTHERS THEN
                l_success := FALSE;
                l_err_msg := SQLERRM;
                DBMS_OUTPUT.PUT_LINE(
                    'Error inserting row '||l_seq_no||' : '||l_err_msg
                );
        END;
    END LOOP;

    -- 5. Cleanup temp file
    DELETE FROM apex_application_temp_files
     WHERE filename = l_file_name;

    -- 6. Update header status
    IF l_success THEN
        l_status := 'SCHEDULED';
    ELSE
        l_status := 'SCHEDULED';
    END IF;

    UPDATE eres_bulk_res_upload_smry
       SET job_status = l_status
     WHERE job_id = l_job_id;



    COMMIT;

    -- 7. Optionally set JOB_ID in a page item
    :P21_NEW_1_JOBID := l_job_id;
    :JOB_ID := :P21_NEW_1_JOBID;
    :TOTAL_ROW_COUNT := l_row_count;
    :TOTAL_COUNT := l_row_count;

EXCEPTION
    WHEN OTHERS THEN
        l_err_msg := SQLERRM;
        DBMS_OUTPUT.PUT_LINE('Fatal error: '||l_err_msg);
        ROLLBACK;
END;

















DECLARE
    l_blob      BLOB;
    l_file_name VARCHAR2(255);
    l_err_msg   VARCHAR2(4000);
    l_job_id    NUMBER;
    l_seq_no    NUMBER := 0;
    l_success   BOOLEAN := TRUE;
    l_status    VARCHAR2(20);
    l_row_count NUMBER := 0;            -- number of rows actually parsed & inserted
    l_parsed_rows NUMBER := 0;          -- parsed row count (for diagnostics)
    l_total_csv_lines NUMBER := NULL;   -- only for CSV/TXT: total lines in raw file (includes blank lines)
    l_row_count_report NUMBER := 0;     -- final value that will be assigned to page items (includes blanks for CSV)
    l_ext        VARCHAR2(10);
BEGIN
    -- 1. Get latest uploaded file from APEX temp files
    SELECT blob_content, filename
      INTO l_blob, l_file_name
      FROM (
        SELECT blob_content, filename
          FROM apex_application_temp_files
         WHERE application_id = :APP_ID
         ORDER BY created_on DESC
      )
     WHERE ROWNUM = 1;

    -- determine extension (lowercase)
    l_ext := LOWER(NVL(SUBSTR(l_file_name, INSTR(l_file_name, '.', -1) + 1), ''));
    DBMS_OUTPUT.PUT_LINE('Uploaded filename: ' || l_file_name || '  extension: ' || NVL(l_ext,'(none)'));

    -- If CSV/TXT, attempt to count raw lines (includes blank lines)
    IF l_ext IN ('csv','txt') THEN
        DECLARE
            -- temporary variables for reading blob in chunks
            l_amount     PLS_INTEGER := 32767;
            l_pos        INTEGER := 1;
            l_blob_len   INTEGER := DBMS_LOB.getlength(l_blob);
            l_raw        RAW(32767);
            l_chunk_vc   VARCHAR2(32767);
            l_accum      CLOB;
            l_nl_count   INTEGER := 0;
            l_piece      VARCHAR2(32767);
            l_chunk_size PLS_INTEGER := 32767;
        BEGIN
            DBMS_LOB.CREATETEMPORARY(l_accum, TRUE);
            WHILE l_pos <= l_blob_len LOOP
                DBMS_LOB.READ(l_blob, LEAST(l_chunk_size, l_blob_len - l_pos + 1), l_pos, l_raw);
                -- try to convert raw to varchar2 (works for CSV encoded in database character set)
                BEGIN
                    l_chunk_vc := UTL_RAW.CAST_TO_VARCHAR2(l_raw);
                EXCEPTION
                    WHEN OTHERS THEN
                        -- if conversion fails, stop counting — fallback will be used later
                        l_chunk_vc := NULL;
                        EXIT;
                END;

                IF l_chunk_vc IS NOT NULL THEN
                    DBMS_LOB.WRITEAPPEND(l_accum, LENGTH(l_chunk_vc), l_chunk_vc);
                END IF;

                l_pos := l_pos + LENGTH(l_chunk_vc);
            END LOOP;

            IF DBMS_LOB.GETLENGTH(l_accum) > 0 THEN
                -- count newline occurrences. support both CRLF and LF.
                -- convert to simple string for processing in manageable chunks
                DECLARE
                    l_text CLOB := l_accum;
                    l_text_len INTEGER := DBMS_LOB.GETLENGTH(l_text);
                    l_scan_pos INTEGER := 1;
                    l_chunk VARCHAR2(32767);
                    l_sub VARCHAR2(32767);
                BEGIN
                    -- We will scan in chunks to count occurrences of CHR(10). This counts lines (LF).
                    WHILE l_scan_pos <= l_text_len LOOP
                        l_chunk := DBMS_LOB.SUBSTR(l_text, 32767, l_scan_pos);
                        -- normalize CRLF to LF to handle windows line endings
                        l_chunk := REPLACE(l_chunk, CHR(13)||CHR(10), CHR(10));
                        -- count LF
                        DECLARE
                            i PLS_INTEGER := 1;
                        BEGIN
                            FOR i IN 1 .. LENGTH(l_chunk) LOOP
                                IF SUBSTR(l_chunk, i, 1) = CHR(10) THEN
                                    l_nl_count := l_nl_count + 1;
                                END IF;
                            END LOOP;
                        END;
                        l_scan_pos := l_scan_pos + LENGTH(l_chunk);
                    END LOOP;

                    -- If file doesn't end with newline, then lines = nl_count + 1, unless file is empty
                    IF l_nl_count = 0 THEN
                        IF l_text_len = 0 THEN
                            l_total_csv_lines := 0;
                        ELSE
                            l_total_csv_lines := 1;
                        END IF;
                    ELSE
                        -- Check last character: if last char is newline then total lines = nl_count (because last line is terminated),
                        -- otherwise nl_count + 1
                        IF DBMS_LOB.SUBSTR(l_text, 1, GREATEST(1, l_text_len)) = CHR(10) THEN
                            l_total_csv_lines := l_nl_count;
                        ELSE
                            l_total_csv_lines := l_nl_count + 1;
                        END IF;
                    END IF;
                END;
            END IF;

            -- free temporary clob
            IF DBMS_LOB.ISTEMPORARY(l_accum) = 1 THEN
                DBMS_LOB.FREETEMPORARY(l_accum);
            END IF;

            DBMS_OUTPUT.PUT_LINE('CSV total lines (including blank ones): ' || NVL(TO_CHAR(l_total_csv_lines), 'NULL'));
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('CSV line-counting fallback failed: ' || SQLERRM);
                l_total_csv_lines := NULL;
                -- continue; we will rely on parsed rows
        END;
    ELSE
        DBMS_OUTPUT.PUT_LINE('Not a CSV/TXT file; blank-line detection not available for binary Excel formats.');
    END IF;

    -- 2. Generate JOB_ID from your sequence
    SELECT bulk_resolution_seq.NEXTVAL INTO l_job_id FROM dual;

    -- 3. Insert header record
    INSERT INTO eres_bulk_res_upload_smry (
        job_id, created_by, created_dt, job_status
    ) VALUES (
        l_job_id, :APP_USER, SYSDATE, 'PENDING'
    );

    -- 4. Loop through Excel rows (this is unchanged — parser will return rows it recognizes)
    FOR rec IN (
        SELECT col001 AS pts_res_group_id
          FROM TABLE(
            apex_data_parser.parse(
                p_content   => l_blob,
                p_file_name => l_file_name,
                p_skip_rows => 1
            )
          )
    )
    LOOP
        l_seq_no := l_seq_no + 1;
        l_row_count := l_row_count + 1;     -- parsed & inserted rows

        BEGIN
            -- Always insert row, classify VALID vs INVALID
            IF REGEXP_LIKE(rec.pts_res_group_id, '^\d+$') THEN
                INSERT INTO eres_bulk_res_upload_detail (
                    job_id, seq_no, pts_res_group_id, row_status, status
                ) VALUES (
                    l_job_id, l_seq_no, rec.pts_res_group_id, 'VALID', NULL
                );
            ELSE
                INSERT INTO eres_bulk_res_upload_detail (
                    job_id, seq_no, pts_res_group_id, row_status, status
                ) VALUES (
                    l_job_id, l_seq_no, rec.pts_res_group_id, 'INVALID', NULL
                );
                l_success := FALSE; -- mark job as failed if any invalid
            END IF;

        EXCEPTION
            WHEN OTHERS THEN
                l_success := FALSE;
                l_err_msg := SQLERRM;
                DBMS_OUTPUT.PUT_LINE(
                    'Error inserting row '||l_seq_no||' : '||l_err_msg
                );
        END;
    END LOOP;

    -- parsed rows count (diagnostic)
    l_parsed_rows := l_row_count;
    DBMS_OUTPUT.PUT_LINE('Parsed rows inserted = ' || l_parsed_rows);

    -- If CSV and CSV total lines known, compute final reported count including blank lines
    IF l_total_csv_lines IS NOT NULL THEN
        -- total rows to report = total CSV lines; parsed rows may be less if parser skipped rows with no recognized columns
        l_row_count_report := l_total_csv_lines;
        -- If parsed rows exceed counted lines (unlikely), fall back to parsed rows
        IF l_row_count_report < l_parsed_rows THEN
            l_row_count_report := l_parsed_rows;
        END IF;
        DBMS_OUTPUT.PUT_LINE('Reporting TOTAL_ROW_COUNT based on CSV raw line count: ' || l_row_count_report ||
                             ' (parsed/inserts='||l_parsed_rows||')');
    ELSE
        -- fallback: use parsed rows as total
        l_row_count_report := l_parsed_rows;
        DBMS_OUTPUT.PUT_LINE('Reporting TOTAL_ROW_COUNT based on parsed rows = ' || l_row_count_report);
    END IF;

    -- 5. Cleanup temp file
    DELETE FROM apex_application_temp_files
     WHERE filename = l_file_name;

    -- 6. Update header status
    IF l_success THEN
        l_status := 'SCHEDULED';
    ELSE
        l_status := 'SCHEDULED';
    END IF;

    UPDATE eres_bulk_res_upload_smry
       SET job_status = l_status
     WHERE job_id = l_job_id;

    COMMIT;

    -- 7. Optionally set JOB_ID in a page item (preserve your original assignments)
    :P21_NEW_1_JOBID := l_job_id;
    :JOB_ID := :P21_NEW_1_JOBID;
    -- set totals: use the computed report count (includes blank lines when CSV)
    :TOTAL_ROW_COUNT := l_row_count_report;
    :TOTAL_COUNT := l_row_count_report;

    DBMS_OUTPUT.PUT_LINE('Final TOTAL_ROW_COUNT set to: ' || NVL(TO_CHAR(l_row_count_report),'0'));

EXCEPTION
    WHEN OTHERS THEN
        l_err_msg := SQLERRM;
        DBMS_OUTPUT.PUT_LINE('Fatal error: '||l_err_msg);
        ROLLBACK;
END;